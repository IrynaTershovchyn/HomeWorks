'number' + 3 + 3 // number33 -> об'єднання

null + 3 //3 -> null буде сприйматись як відсутність значення

5 && "qwerty" //qwerty -> 5 сприйметься, як true, тому виведеться останнє значення

+'40' + +'2' + "hillel"; //42hillel -> унарний + зробить зі стрінги число

'10' - 5 === 6; //false -> 5 не дорівнює 6

true + false //1 -> true=1, а false=0

'4px' - 3 //Nan -> від string не можна відняти number

'4' - 3 //1 -> 4 сприйметься, як число, а 4-3=1

'6' + 3 ** 0; //61 -> спочатку буде зведення в степінь (чило в нульовій степені дорівнює 1), а потім об'єднання, як в першому прикладі

12 / '6' //2 -> 6 сприйметься як number

'10' + (5 === 6); //10false -> буде об'єднання, а операція в дужках це false

null == '' //true -> null як false, і пуста строка як false. P.S. це я так думала, але проранила в консолі і дійшло, що == порівнює саме значення, а null не дорівнює жодному іншому значенню, тому видає false

3 ** (9 / 3); //27 -> три в третій степені

!!'false' == !!'true' //true -> не пусті рядки !! переведе в true

0 || '0' && 1 //1 -> виведе останнє значення 1, тому що всі попередні true

(+null == false) < 1; //false -> 1 не меньше 1

false && true || true //false -> тому що при порівняні через && є false. P.S. в консольці вийшло true, напевно, що після отримання false в першому стейтмені порівння пішло далі -> false||true отримуємо true

false && (false || true); //false -> а тут останім йде порівняння &&, тому false

(+null == false) < 1 ** 5; ////false -> 1 не меньше 1
